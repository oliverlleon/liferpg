    function resetTaskForm() {
        taskForm.title.value = '';
        taskForm.durationHours.value = '';
        taskForm.durationMinutes.value = '';
        taskForm.deadline.value = '';
        taskForm.notes.value = ''; // Limpa as notas
        taskForm.subtaskInput.value = '';
        selectedTaskType = null;
        selectedTaskPriority = 'contrato'; // Reseta para o padrão
        recurrenceRule = null; // Limpa a regra de recorrência
        taskForm.recurrenceSummary.textContent = ''; // Limpa o resumo
        aiResults = null;
        calculatedRewards = null;
        subtasksList = []; // Limpa a lista de sub-tarefas
        renderSubtasks(); // Atualiza a UI para remover as sub-tarefas
        
        taskForm.typeButtons.forEach(btn => btn.classList.remove('task-type-selected'));
        taskForm.priorityButtons.forEach(btn => btn.classList.remove('task-priority-selected'));

        rewardBox.loading.classList.remove('hidden');
        rewardBox.loadingText.textContent = 'Digite sua missão para calcularmos a recompensa...';
        rewardBox.spinner.classList.add('hidden');
        rewardBox.results.classList.add('hidden');
    }

    /**
     * Renderiza a lista de sub-tarefas na UI
     */
    function renderSubtasks() {
        taskForm.subtaskList.innerHTML = '';
        subtasksList.forEach((task, index) => {
            const taskEl = document.createElement('div');
            taskEl.className = 'flex items-center justify-between bg-surface-dark/50 p-3 rounded-lg';
            taskEl.innerHTML = `
                <span class="text-white/90">${task.titulo}</span>
                <button data-index="${index}" class="remove-subtask-btn flex items-center justify-center h-6 w-6 rounded-full text-red-400 hover:bg-red-400/20">
                    <span class="material-symbols-outlined text-base">close</span>
                </button>
            `;
            taskForm.subtaskList.appendChild(taskEl);
        });
    }

    /**
     * Lógica para adicionar e remover sub-tarefas
     */
    taskForm.addSubtaskBtn.addEventListener('click', () => {
        const title = taskForm.subtaskInput.value.trim();
        if (title) {
            subtasksList.push({ titulo: title, concluida: false });
            taskForm.subtaskInput.value = '';
            renderSubtasks();
            triggerAIAnalysis(); // Re-analisa quando uma sub-tarefa é adicionada
        }
    });

    taskForm.subtaskList.addEventListener('click', (e) => {
        const removeBtn = e.target.closest('.remove-subtask-btn');
        if (removeBtn) {
            const index = parseInt(removeBtn.dataset.index, 10);
            subtasksList.splice(index, 1);
            renderSubtasks();
            triggerAIAnalysis(); // Re-analisa quando uma sub-tarefa é removida
        }
    });
    
    /**
     * Seleciona o tipo de tarefa (Hábito, Diária, Projeto)
     */
    taskForm.typeGroup.addEventListener('click', (e) => {
        const button = e.target.closest('.task-type-btn');
        if (!button) return;
        
        selectedTaskType = button.dataset.type;
        
        taskForm.typeButtons.forEach(btn => btn.classList.remove('task-type-selected'));
        button.classList.add('task-type-selected');
        
        triggerAIAnalysis(); // Re-analisa quando o tipo muda
    });

    /**
     * Seleciona a prioridade da tarefa
     */
    taskForm.priorityGroup.addEventListener('click', (e) => {
        const button = e.target.closest('.task-priority-btn');
        if (!button) return;

        selectedTaskPriority = button.dataset.priority;

        taskForm.priorityButtons.forEach(btn => btn.classList.remove('task-priority-selected'));
        button.classList.add('task-priority-selected');
    });

    /**
     * Lógica do Modal de Recorrência
     */
    taskForm.openRecurrenceBtn.addEventListener('click', (e) => {
        e.preventDefault(); // Previne comportamento de formulário
        recurrenceModal.container.classList.remove('hidden');
    });
    recurrenceModal.cancelBtn.addEventListener('click', () => {
        recurrenceModal.container.classList.add('hidden');
    });
    // Limpa dias da semana se input de dias for usado
    recurrenceModal.daysInput.addEventListener('input', () => {
        recurrenceModal.weekdayButtons.forEach(btn => btn.classList.remove('weekday-btn-selected'));
    });
    // Limpa input de dias se dias da semana forem usados
    recurrenceModal.weekdaysGroup.addEventListener('click', (e) => {
        const button = e.target.closest('.weekday-btn');
        if (button) {
            recurrenceModal.daysInput.value = '';
            button.classList.toggle('weekday-btn-selected');
        }
    });
    recurrenceModal.saveBtn.addEventListener('click', () => {
        const days = parseInt(recurrenceModal.daysInput.value, 10);
        const selectedWeekdays = [...recurrenceModal.weekdayButtons]
            .filter(btn => btn.classList.contains('weekday-btn-selected'))
            .map(btn => parseInt(btn.dataset.day, 10));

        if (days > 0) {
            recurrenceRule = { type: 'days', value: days };
            taskForm.recurrenceSummary.textContent = `Repete a cada ${days} dia(s).`;
        } else if (selectedWeekdays.length > 0) {
            recurrenceRule = { type: 'weekdays', value: selectedWeekdays.sort() };
            const dayNames = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'];
            const summary = selectedWeekdays.map(d => dayNames[d]).join(', ');
            taskForm.recurrenceSummary.textContent = `Repete em: ${summary}.`;
        } else {
            recurrenceRule = null;
            taskForm.recurrenceSummary.textContent = '';
        }
        recurrenceModal.container.classList.add('hidden');
    });


    /**
     * Dispara a análise da IA após o usuário digitar o título ou duração
     */
    function triggerAIAnalysis() {
        const title = taskForm.title.value.trim();
        const hours = parseInt(taskForm.durationHours.value, 10) || 0;
        const minutes = parseInt(taskForm.durationMinutes.value, 10) || 0;
        const totalMinutes = (hours * 60) + minutes;
        
        // A IA só é chamada se tivermos o Título e o Tipo de Missão
        if (title.length < 3 || !selectedTaskType) {
             rewardBox.loading.classList.remove('hidden');
             rewardBox.loadingText.textContent = 'Preencha o Título e o Tipo de Missão...';
             rewardBox.spinner.classList.add('hidden');
             rewardBox.results.classList.add('hidden');
            return;
        }
        
        rewardBox.loading.classList.remove('hidden');
        rewardBox.loadingText.textContent = 'Analisando missão...';
        rewardBox.spinner.classList.remove('hidden');
        rewardBox.results.classList.add('hidden');
        
        debounce(() => analyzeTaskWithAI(title, totalMinutes, selectedTaskType, subtasksList), 1000); // Atraso de 1 seg
    }
    
    taskForm.title.addEventListener('keyup', triggerAIAnalysis);
    taskForm.durationHours.addEventListener('keyup', triggerAIAnalysis);
    taskForm.durationMinutes.addEventListener('keyup', triggerAIAnalysis);
    
    /**
     * Chama a API do Gemini para análise
     */
    async function analyzeTaskWithAI(taskTitle, totalMinutes, taskType, subtasks) {
        console.log(`Analisando: Tipo=${taskType}, Título='${taskTitle}', Duração=${totalMinutes} min, Sub-tarefas=${subtasks.length}`);
        
        const apiKey = "AIzaSyCF4tD2jq3pEHfuilwMq-fjdUnBZDxcoxM"; // Chave que funciona
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        // Construindo a string das sub-tarefas para o prompt
        const subtasksString = JSON.stringify(subtasks.map(s => s.titulo));

        // Prompt Mestre (conforme especificação)
        const combinedPrompt = `Você é um mestre de jogo (Game Master) de um RPG da vida real. Sua função é analisar tarefas e classificá-las. Responda APENAS com um objeto JSON. Não inclua \`\`\`json ou qualquer texto antes ou depois.

Analise a tarefa. Considere o TIPO, Título, Duração e Sub-tarefas para definir o atributo_associado (FORCA, INTELIGENCIA, VELOCIDADE, VITALIDADE, CARISMA) e a dificuldade (FACIL, MEDIA, DIFICIL).

Use estas definições de Atributo:
FORCA: Academia, levantar peso, limpeza pesada.
INTELIGENCIA: Estudar, ler, planejar, meditar, aprender.
VELOCIDADE: Correr, organizar, tarefas rápidas, caminhada.
VITALIDADE: Beber água, comer saudável, dormir, tomar sol.
CARISMA: Socializar, ligar para amigos, networking, apresentação.

Regras de Dificuldade (INTELIGENTE - Use o TIPO como base):
TIPO 'habito': É quase sempre FACIL. (Ex: 'Beber água', 'Meditar 5 min'). Só será MEDIA se a Duração for > 30 min. Um Hábito NUNCA pode ser 'DIFICIL'.
TIPO 'diaria': É quase sempre MEDIA. (Ex: 'Ir na academia', 'Correr 30 min'). Só será 'DIFICIL' se Duração > 90 min OU tiver 4+ sub-tarefas.
TIPO 'projeto': É quase sempre DIFICIL. (Ex: 'Fazer TCC', 'Limpar a casa toda'). Só será 'MEDIA' se tiver 0 sub-tarefas E Duração < 60 min.

Exemplos de Classificação:
TIPO: 'habito', Título: 'Beber água 1 copo', Duração: 1, Sub-tarefas: [] -> {"atributo_associado": "VITALIDADE", "dificuldade": "FACIL"}
TIPO: 'diaria', Título: 'Correr', Duração: 30, Sub-tarefas: [] -> {"atributo_associado": "VELOCIDADE", "dificuldade": "MEDIA"}
TIPO: 'projeto', Título: 'Estudar p/ prova', Duração: 60, Sub-tarefas: [] -> {"atributo_associado": "INTELIGENCIA", "dificuldade": "MEDIA"}
TIPO: 'projeto', Título: 'Estudar p/ prova', Duração: 60, Sub-tarefas: ["Ler", "Resumir"] -> {"atributo_associado": "INTELIGENCIA", "dificuldade": "DIFICIL"}

Tarefa:
TIPO: '${taskType}'
Título: '${taskTitle}'
Duração (minutos): ${totalMinutes}
Sub-tarefas: ${subtasksString}`;

        const responseSchema = {
            type: "OBJECT",
            properties: {
                "atributo_associado": { "type": "STRING" },
                "dificuldade": { "type": "STRING" }
            },
            required: ["atributo_associado", "dificuldade"]
        };
        
        const payload = {
            contents: [{ parts: [{ text: combinedPrompt }] }],
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: responseSchema,
                temperature: 0.1
            }
        };

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`Erro na API: ${response.statusText}`);
            }

            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (!text) {
                 throw new Error("A IA não retornou uma análise válida.");
            }

            aiResults = JSON.parse(text);
            console.log("Resultado da IA:", aiResults);
            
            updateRewardEstimation(aiResults.atributo_associado, aiResults.dificuldade);

        } catch (error) {
            console.error("Erro ao analisar tarefa:", error);
            rewardBox.loading.classList.remove('hidden');
            rewardBox.loadingText.textContent = 'Erro ao analisar. Tente novamente.';
            rewardBox.spinner.classList.add('hidden');
            rewardBox.results.classList.add('hidden');
            aiResults = null;
        }
    }
    
    /**
     * Atualiza a caixa de estimativa de recompensa
     */
     function updateRewardEstimation(attribute, difficulty) {
        if (!selectedTaskType) {
            rewardBox.loading.classList.remove('hidden');
            rewardBox.loadingText.textContent = 'Selecione um Tipo de Missão...';
            rewardBox.spinner.classList.add('hidden');
            rewardBox.results.classList.add('hidden');
            return;
        }

        const typeKey = selectedTaskType.toLowerCase();
        const difficultyKey = difficulty.toUpperCase();
        const attributeKey = attribute.toUpperCase();

        const typeRewards = REWARDS_TYPE[typeKey] || { xp_global: 0, moedas: 0 };
        const difficultyRewards = REWARDS_DIFFICULTY[difficultyKey] || { xp_attr: 0 };
        
        calculatedRewards = {
            xp_global: typeRewards.xp_global,
            xp_atributo: difficultyRewards.xp_attr,
            moedas: typeRewards.moedas
        };

        rewardBox.attribute.textContent = attributeKey;
        rewardBox.difficulty.textContent = difficultyKey;
        rewardBox.xpGlobal.textContent = `+${calculatedRewards.xp_global} XP`;
        rewardBox.xpAttributeLabel.textContent = `XP de ${attributeKey}:`;
        rewardBox.xpAttribute.textContent = `+${calculatedRewards.xp_atributo} XP`;
        rewardBox.coins.textContent = `+${calculatedRewards.moedas} Moedas`;
        
        rewardBox.loading.classList.add('hidden');
        rewardBox.results.classList.remove('hidden');
     }
     
    /**
     * Salva a nova tarefa no Firestore
     */
    taskForm.saveBtn.addEventListener('click', async () => {
        const title = taskForm.title.value.trim();
        const hours = parseInt(taskForm.durationHours.value, 10) || 0;
        const minutes = parseInt(taskForm.durationMinutes.value, 10) || 0;
        const totalMinutes = (hours * 60) + minutes;
        
        // Validação
        if (title.length < 3) {
            return showMessage('Missão Inválida', 'O título da missão é muito curto.');
        }
        if (!selectedTaskType) {
            return showMessage('Missão Inválida', 'Selecione um tipo de missão (Hábito, Diária ou Projeto).');
        }
        if (!aiResults || !calculatedRewards) {
            return showMessage('Missão Inválida', 'Aguarde a análise da IA terminar antes de salvar.');
        }
        if (!currentUserId) {
            return showMessage('Erro', 'Usuário não encontrado. Tente relogar.');
        }
        
        const isRecurrenceTemplate = recurrenceRule !== null;

        const taskData = {
            titulo: title,
            tipo: selectedTaskType,
            prioridade: selectedTaskPriority,
            notas: taskForm.notes.value.trim() || null,
            recorrencia: recurrenceRule,
            isTemplate: isRecurrenceTemplate,
            lastGenerated: null,
            duracao_estimada_minutos: totalMinutes > 0 ? totalMinutes : null, // Salva os minutos totais
            atributo_associado: aiResults.atributo_associado,
            dificuldade: aiResults.dificuldade,
            recompensa: calculatedRewards,
            concluida: false,
            createdAt: Timestamp.now(),
            prazo_final: taskForm.deadline.value || null,
            subtarefas: subtasksList
        };
        
        try {
            const tasksRef = collection(db, 'artifacts', appId, 'users', currentUserId, 'tasks');
            await addDoc(tasksRef, taskData);
            
            console.log('Missão salva:', taskData);
            showMessage('Sucesso!', 'Sua nova missão foi adicionada ao registro!');
            showScreen('dashboard');
            
        } catch (error) {
            console.error("Erro ao salvar missão:", error);
            showMessage('Erro no Firestore', `Não foi possível salvar sua missão. Erro: ${error.message}`);
        }
    });

    // --- Inicialização da Aplicação ---
    // A FUNÇÃO DE INICIALIZAÇÃO AUTOMÁTICA FOI REMOVIDA.

  </script>

</body>
</html>
